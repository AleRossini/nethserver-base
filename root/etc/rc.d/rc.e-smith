#!/bin/bash
#
# Customisation of the RedHat rc script, which allows services to return
# a value of 99, indicating "disabled"

# Check whether file $1 is a backup or rpm-generated file and should be ignored
is_ignored_file() {
    case "$1" in
	*~ | *.bak | *.orig | *.rpmnew | *.rpmorig | *.rpmsave)
	    return 0
	    ;;
    esac
    return 1
}

# check a file to be a correct runlevel script
check_runlevel ()
{
	# Check if the file exists at all.
	[ -x "$1" ] || return 1
	is_ignored_file "$1" && return 1
	return 0
}

# Now find out what the current and what the previous runlevel are.
argv1="$1"
set `/sbin/runlevel`
runlevel=$2
previous=$1
export runlevel previous

# Source function library.
. /etc/init.d/functions

# Now redefine some of the functions, and add one or two of our own.
#

echo_success() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "[  "
  [ "$BOOTUP" = "color" ] && $SETCOLOR_SUCCESS
  echo -n $"OK"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "  ]"
  echo -ne "\r"
  return 0
}

echo_failure() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
  echo -n $"FAILED"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  echo -ne "\r"
  return 1
}

echo_disabled() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "[  "
  [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
  echo -n "OFF"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n " ]"
  echo -ne "\r"
  return 1
}

echo_warning() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
  echo -n $"WARNING"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  echo -ne "\r"
  return 1
}

# Log that something succeeded
success() {
  [ "$BOOTUP" != "verbose" -a -z "$LSB" ] && echo_success
  return 0
}

# Log that something failed
failure() {
  local rc=$?
  [ "$BOOTUP" != "verbose" -a -z "$LSB" ] && echo_failure
  return $rc
}

# Log a warning
warning() {
  local rc=$?
  [ "$BOOTUP" != "verbose" -a -z "$LSB" ] && echo_warning
  return $rc
}  

# Log that something passed, but is disabled in this configuration
disabled() {
  local rc=$?
  [ "$BOOTUP" != "verbose" ] && echo_disabled
  return $rc
}  

# Run some action. Log its output.
action() {
  local STRING=$1
  echo -n "$STRING "
  shift
  "$@"
  local ret=$?
  case $ret in
      0) success $"$STRING" ;;
      99) disabled $"$STRING"
          ret=0 ;;
      *) failure $"$STRING" ;;
  esac
  echo
  return $ret
}

# See if we want to be in user confirmation mode
if [ "$previous" = "N" ]; then
	if [ -f /var/run/confirm ]; then
		echo $"Entering interactive startup"
	else
		echo $"Entering non-interactive startup"
	fi
fi

# Get first argument. Set new runlevel to this argument.
[ -n "$argv1" ] && runlevel="$argv1"

# Is there an rc directory for this new runlevel?
[ -d /etc/rc$runlevel.d ] || exit 0

# First, run the KILL scripts.
for i in /etc/rc$runlevel.d/K* ; do
	check_runlevel "$i" || continue

	# Check if the subsystem is already up.
	subsys=${i#/etc/rc$runlevel.d/K??}
	[ -f /var/lock/subsys/$subsys -o -f /var/lock/subsys/$subsys.init ] \
		|| continue

	# Bring the subsystem down.
	if LC_ALL=C egrep -q "^..*init.d/functions" $i ; then
		$i stop
	else
		action $"Stopping $subsys: " $i stop
	fi
done

# Now run the START scripts.
for i in /etc/rc$runlevel.d/S* ; do
	check_runlevel "$i" || continue

	# Check if the subsystem is already up.
	subsys=${i#/etc/rc$runlevel.d/S??}
	[ -f /var/lock/subsys/$subsys -o -f /var/lock/subsys/$subsys.init ] \
		&& continue
		    
	# If we're in confirmation mode, get user confirmation
	if [ -f /var/run/confirm ]; then
		confirm $subsys
		test $? = 1 && continue
	fi

	update_boot_stage "$subsys"
	# Bring the subsystem up.
	if [ "$subsys" = "halt" -o "$subsys" = "reboot" ]; then
		export LC_ALL=C
		exec $i start
	fi
	if LC_ALL=C egrep -q "^..*init.d/functions" $i \
			|| [ "$subsys" = "single" -o "$subsys" = "local" ]; then
		$i start
	else
		action $"Starting $subsys: " $i start
	fi
done
rm -f /var/run/confirm
if [ -x /usr/bin/rhgb-client ] && /usr/bin/rhgb-client --ping ; then
  /usr/bin/rhgb-client --quit
fi

